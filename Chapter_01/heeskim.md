# 디자인 패턴의 세계로 떠나기
## 디자인 패턴 소개와 전략 패턴
### 학습목표
- 디자인 패턴의 활용분야, 디자인 패턴으로 얻을 수 있는 장점을 알아보기
- 핵심적인 객체지향 디자인 원칙을 몇개 살펴보고, 한가지를 정해 디자인 원칙이 어떤식으로 작동하는지 알아보기
- 디자인 패턴은 코드가 아니라, **경험**. 그러니까 패턴을 기억하고 어떻게 적용할지를 파악해야함.
### 오리 시뮬레이션 게임, SimUduck
표준 객체 지향 기법을 사용 => Duck 이라는 슈퍼클래스를 만들고 클래스를 확장해 서로 다른 오리를 구성
이후 나는 동작을 추가하고 싶어서 슈퍼클래스에 추가 -> 날면안되는 오리도 날아버림
#### 쓰면서 제대로 공부하기 
A,B,D,F
#### 인터페이스 설계하기 : 상속은 올바른 해결책이 아니야!
6개월마다 제품을 업데이트하기로 했음. -> 규격이 바뀔 때마다 프로그램에 추가했던 서브클래스 fly, quack을 일일이 살펴보고 상황에 따라 오버라이드해야하는 경우가 생김
=> 특정 오리만 날거나 꽤꽥거리도록 하는 더 깔꼬롬한 방법이 필요해짐!

fly, quack을 가지고 있는 flyable, quackable같은 클래스를 만들수도 있지만, 그러면 코드 중복이 심해지고 오리중에서도 날아다니는 방식이 여러가지일 경우 코드를 전부 수정해야될수도 있음.
=> 다른 방식이 필요!

### 변화 : 소프트웨어 개발 불변의 진리
아무리 디자인을 잘한 어플리케이션도 시간이 지남에 따라 변화하고 성장해야함. 
#### 쓰면서 제대로 공부하기 
변화의 원인? 
- 고객이나 사용자가 다른것을 요구 / 새로운 기능을 원함
- 회사에서 데이터 베이스 종류를 바꾸고 데이터도 전과 다른데서 구입하리고 했는데, 지금 사용하는 데이터 포맷과 전혀 다른 경우 
- 사용하던 라이브러리가 업데이트되어 이전에 사용하던 방식과 맞지 않을 경우
- 기술이 발전하면서 새로운 규약을 사용하려고 코드를 갱신
- 시스템을 만드는 과정에서 여러가지 배우고 나니 다시 앞부분을 고치고 싶어서
### 디자인 원칙 1
애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 "캡슐화"하면 코드를 변경하는 과정에서 의도치 않게 발생하는 일을 줄이고 시스템의 유연성을 향상시킬 수 있음! 
이건 다른 모든 디자인 패턴의 기반을 이루는 원칙!! 
### 바뀌는 부분과 그렇지 않은 부분 분리하기
나는것과 관련된 부분, 꽥꽥거리는 것과 관련된 부분을 분리해서 2개의 클래스 집합을 만들기
- 최대한 유연하게 만들기 
- Duck 인스턴스에 행동을 할당하기 
- 오리의 행동을 동적으로 변경하기
### 디자인 원칙 2
구현보다는 인터페이스에 맞춰서 프로그래밍한다.

행동을 Duck 클래스에서 구체적으로 구현하거나, 서브클래스 자체에서 별도로 구현하는 방법과는 상반된 방법. 
Duck 서브클래스는 인터페이스 FlyBehavior/ QuackBehavior로 표현되는 행동을 사용해서, 실제 행동구현이 FlyBehavior/QuachBehavior클래스에 코딩되어있기 때문에 Duck 서브 클래스에 국한되지 않는다. 따라서, Duck클래스에서 그 행동을 구체적으로 구현할 필요가 없다.

#### "인터페이스에 맞춰서 프로그래밍한다" = "상위형식에 맞춰서 프로그래밍한다"
핵심은 
- 실제 실행시에 쓰이는 객체가 코드에 고정되지 않도록 상위형식(supertype)에 맞춰서 프로그래밍해서 다형성을 활용해야 한다는 것
- 변수를 선언할 때 보통 추상클래스나 인터페이스 같은 상위형식으로 선언하는것.
- 그래야 객체를 변수에 대입할 때 어떤 객체든 넣을 수 있고, 변수를 가지고 있는 클래스에서 실제 객체의 형식을 몰라도 되기 때문.
ex) Animal - Cat
		  |- Dog 
	Animal이라는 추상 클래스가 있고, 그 밑에 Dog, Cat이라는 구상 클래스가 있다면, 
	```Dog d = new Dog()```
	이렇게 프로그래밍하면 구체적인 구현에 맞춰야하지만,
	```Animal animal = new Dog();```
	이렇게 프로그래밍하면 다형성을 활용할 수 있다.

### 오리의 행동을 구현하는 방법 : 디자인 원칙 2 적용

> 사진  - p.49

FlyBehavior와 QuackBehavior 2개의 인터페이스와, 
구체적인 행동을 구현하는 5개의 클래스가 있다. 

이런식으로 디자인하면 다른형식의 개체에서 나는 행동과 꽥꽥거리는 행동을 재사용할 수 있다.
또한 기존 행동 클래스를 수정하거나 날아다니는 행동을 사용하는 Duck클래스를 건드리지 않고 새로운 행동을 추가할 수 있다.

### 오리 행동 통합하기
**가장 중요한것 : 행동을** Duck 클래스 / 서브 클래스에서 정의한 메소들 써서 구현하지 않기 
**다른 클래스에게 위임**하기

1. Duck 클래스에 flyBehavior와 quackBehavior 인터페이스 형식의 인스턴스 변수 추가
2. Duck 클래스에 fly, quack대신 행동을 수행할  performFly(), performQuack()함수추가
3. 인스턴스 변수 설정하기 ( ```quackBehavior = new Quack() ```)

### 오리 코드 테스트하기 
여기서 책의 실습코드는 java로 되어있지만, 나는 typescript로 해보기

### 동적으로 행동 지정하기
여기도 typescript 코드 만들기
메소드를 호출해서 동적으로 오리의 행동을 바꾸게 하기 : 상속받은 세터 메소드 이용하기 

### 캡슐화된 행동 살펴보기
오리의 행동들을 일련의 행동 대신 알고리즘 군 (family of algorithms)로 생각하기
-> 이 예제에서는 오리가 하는 행동을 나타내지만, 지역에 따라 달라지는 세금 계산 방식을 구현하는 클래스에도 활용할 수 있음

그림을 보고 화살표 ->, ---> , -|> 세가지의 의미를 생각해보기

### 두 클래스를 합치는 방법
A에는 B가 있다. 
각 오리에는 FlyBehavior, QuackBehavior가 있고 각각 나는 행동과 꽥꽥거리는 행동을 위임받음. 
이런식으로 두 클래스를 합치는 것을 **"구성" (composition)** 을 이용한다고 함.

### 디자인 원칙 3
상속보다는 구성을 활용한다.
구성을 활용하면 유연성이 증가한 시스템이 된다.
단순히 알고리즘군을 별도의 클래스 집합으로 캡슐화 할 수 있고, 구성요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행시에 행동을 바꿀 수 있음!


## 첫번째 디자인 패턴 : 전략패턴

그러니까 지금까지 만든 이 오리 시뮬레이터는 이제 전략패턴을 가지고 있는거
### 전략패턴 : Strategy Pattern 
- 알고리즘 군을 정의하고 캡슐화해서 
- 각각의 알고리즘군을 수정해서 쓸수 있게 해줌
- 전략패턴을 사용하면, 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경가능

### 디자인 패턴 소개
공통으로 아는 전문 용어
용어를 이해하고 나면 다른 개발자와 더 쉽게 대화할 수 있음.
패턴 수준에서 생각할 수 있게 되면, 아키텍처를 생각하는 수준도 올라감!
**장점**
- 패턴 이름을 말하는 것만으로 패턴에 담겨있는 모든 내용, 특성, 제약조건을 함께 다룰수 있음
- 간단한 단어로 많은 이야기를 나눌수 있음.
- "디자인"에 오랫동안 집중할 수 있음.
- 오해가 줄고, 작업이 빠르게 진행될 수 있음
- 신입개발자에게 자극제..ㅎ
그러니까, "오리들의 다양한 행동을 전략패턴으로 구현했습니다" 라고 한다면, 
오리의 행동들이 쉽게 확장 / 변경이 가능한 클래스들의 집합으로 캡슐화 되어있다는 뜻. 심지어 필요하다면 실행중에 확장, 변경이 가능하게.

### 디자인 패턴 사용법
- 기성 라이브러리/ 프레임워크를 사용을 많이함
- 근데 그런 라이브러리/ 프레임워크가 이해하기 쉽고 관리하기 쉬운 유연한 애플리케이션 구조를 만들어주는건 아님
- 그 라이브러리/ 프레임 워크 내부 구조가 그렇게 되어있을 수는 있지만, 내가 가져다 쓸때 그렇게 쓰는건 아닐수도
- 이 때 디자인 패턴은 유연한 시스템을 만들어줌!
- 어떤 코드를 적용하는것에서 끝나는게 아니라, 머릿속에서 패턴을 이해하고, 어떤 부분에 적용해야할지 분리하고 그리고 적용해나가는 순서로 진행됨.
- 그러니까 디자인을 특정 어플리케이션에 맞게 적용하는 일은 개발자의 몫!

그리고 결국 모든 패턴은 객체지향의 위에서 설계되었으므로, 디자인 원칙을 제대로 알고 있어야 나중에 패턴을 찾을 수 없을 때 도움이 됨. 
결국 재사용성, 확장성, 관리의 용이성을 위해서 우리는 디자인 패턴을 적용한다는것을 기억해야함.
